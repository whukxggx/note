1. 常见的锁。
2.  ssh是什么原理？
3. cookie,session,token
4. 大数相乘，未解决。
5. 三五原则：
   * 需要析构函数的类也需要拷贝构造函数和拷贝赋值函数。
   * 需要拷贝操作的类也需要赋值操作。
   * 析构函数不能是私有的。
   * 如果一个类有私有的或不可访问的析构函数，那么其默认和拷贝构造函数都会被定义为私有的。
   * 如果一个类有const或引用成员，则不能使用默认的拷贝复制操作。

* **多线程优缺点**

多线程程序在当前的多处理器计算机上用得非常广泛，尤其是高并发程序，那么它有什么优点呢？个人觉得大致有以下几点：

1、多线程充分利用计算机资源；

2、多线程处理，程序响应速度更快。

任何事物都存在两面性，多线程既然有它的优点，那么也存在它的缺点：

1、对程序员来说，比单线程应用更具挑战性，程序设计实现更加复杂；

2、多线程比单线程更加消耗资源，比如CPU、内存等；

3、计算机资源有限，太多的线程运行，会导致上下文频繁切换，甚至出现死锁等情况，出现非预期效果。

 **聚集索引：数据行的物理顺序与列值的逻辑顺序相同，一个表中只能拥有一个聚集索引**

在C++中，内存分为：栈、堆、全局/静态存储区、常量存储区。

栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束是这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率高，分配的内存容量有限。

堆，就是那些由malloc等分配的内存块，用free来释放内存。

全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

**所有的字符窜常量都被放在静态内存区
因为字符串常量很少需要修改，放在静态内存区会提高效率**

**常量字符串如char *p="sam"中的sam标准没有规定存储在哪，一般是存储在常量内存区的，但是如果用char p[]="sam",那么会存储在栈中。（作为数组初始化）**

text段在内存中被映射为只读，但.data和.bss是可写的。

text段:就是放程序代码的,编译时确定,只读；

data段:存放在编译阶段(而非运行时)就能确定的数据,可读可写。也就是通常所说的静态存储区,赋了初值的全局变量和赋初值的静态变量存放在这个区域,**常量也存放在这个区域；**

**bss段:定义而没有赋初值的全局变量和静态变量,放在这个区域；**

* **cas**

CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。

CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。

CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。　　　

* **线程私有的和共享的**

  * **私有**
    * 栈（局部变量，函数参数）
    * 线程局部存储
    * 寄存器

  * **共享**
    * 全局变量
    * 堆上的数据
    * 函数的静态变量
    * 程序代码
    * 打开的文件，a线程打开的可以由b读写

* **内存泄漏**

  * 野指针
    * 指针没有被初始化
    * 指针被free或delete后没有置为null
    * 擦指针操作超越变量的作用范围

  * delete掉一个void*类型导致没有调用析构函数。
  * delete数组没有加[]

* **异步IO模型与信号IO模型的主要区别是信号驱动IO是由内核通知我们何时可以启动一个IO操作，而异步IO模型是由内核通知我们IO操作何时完成**

* **cache和buffer**

  1. Cache：缓存区，是高速缓存，是位于CPU和主内存之间的容量较小但速度很快的存储器，因为CPU的速度远远高于主内存的速度，CPU从内存中读取数据需等待很长的时间，而 Cache保存着CPU刚用过的数据或循环使用的部分数据，这时从Cache中读取数据会更快，减少了CPU等待的时间，提高了系统的性能。

    Cache并不是缓存文件的，而是缓存块的(块是I/O读写最小的单元)；Cache一般会用在I/O请求上，如果多个进程要访问某个文件，可以把此文件读入Cache中，这样下一个进程获取CPU控制权并访问此文件直接从Cache读取，提高系统性能。

  2. Buffer：缓冲区，用于存储速度不同步的设备或优先级不同的设备之间传输数据；通过buffer可以减少进程间通信需要等待的时间，当存储速度快的设备与存储速度慢的设备进行通信时，存储慢的数据先把数据存放到buffer，达到一定程度存储快的设备再读取buffer的数据，在此期间存储快的设备CPU可以干其他的事情。

* **协程**

  协程既不是进程也不是线程，协程仅仅是一个**特殊的函数**，协程它进程和进程不是一个维度的。

  一个进程可以包含多个线程，一个线程可以包含多个协程。

  一个线程内的多个协程虽然可以切换，但是多个协程是**串行执行**的，只能在一个线程内运行，没法利用CPU多核能力。

  协程与进程一样，切换是存在上下文切换问题的。

  协程不是被操作系统内核所管理的，而是**完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。**

* **main函数结束后怎么继续执行一段代码？**

    在main函数执行结束后，还想继续执行一段甚至多段代码，这就需要用**_onexit注册**一个函数，使该函数在main结束后执行。_onexit(funname);其中参数是一个函数名，且该函数无参数，返回值为int。看代码：

* **空类大小**

  1，由于空类也可以实例化，**实例需要独一无二的地址，为此，编译器给空类隐含添加一个字节**

* **对象移动**

  * **右值引用**

    右值引用有一个重要的性质---只能绑定到一个将要销毁的对象。

* **cookie,session,token**

  

* **为什么是三次握手**、
  
  * 要互相确认序号
  
  * 两次可能会无端浪费服务器资源
  
* **HTTP和HTTPS**

  　HTTPS和HTTP的区别主要如下：

    　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

    　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

    　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

    　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

* **mysql连接方式**
  * 内连接
  * 左连接
  * 右连接

* **epoll**

  可以看到，select和epoll最大的区别就是：select只是告诉你一定数目的流有事件了，至于哪个流有事件，还得你一个一个地去轮询，而epoll会把发生的事件告诉你，通过发生的事件，就自然而然定位到哪个流了。不能不说epoll跟select相比，是质的飞跃，我觉得这也是一种**牺牲空间，换取时间的思想**，毕竟现在硬件越来越便宜了。

* **tcp粘包，分包**

  * **粘包**：tcp，连接不断开的情况下，持续不断地将多个数据包发向服务器，**但是如果发送的网络数据包太小，可能会启动nagle算法对较小的数据包进行合并**，这样服务器接收到消息的时候无法区别哪些数据包时客户端分开发送的，就产生了粘包。

  * **分包**：**可能是IP分片传输导致的，可能是传输过程中丢失部分包导致出现的半包，还有可能是一个包分了两次传输**

  * **粘包处理**：一种是**分隔符**，一种是**添加长度信息**
  * **分包**：也可以**分隔符**，如果这次没遇到分隔符，接着下个。

* **内核态，用户态交互**

  * **系统调用**

  * **/proc**

    该目录下的一个文件实际是一个内核变量，内核通过这个目录以文件的形式展现自己的内部信息，相当于/proc目录为用户态和内核态之间的交互搭建了一个桥梁。**用户态读写/proc下的文件，就是读写内核相关的配置参数**

    **常见的有/proc/cpuinfo,/proc/meminfo,/proc/net**

  * **sysctl**

    **一个linux命令，用来修改内核的运行时参数**

    procfs 主要是输出只读数据，而 sysctl 输出的大部分信息是可写的。

    例如，我们比较常见的是通过 `cat /proc/sys/net/ipv4/ip_forward` 来获取内核网络层是否允许转发 IP 数据包，通过 `echo 1 > /proc/sys/net/ipv4/ip_forward` 或者 `sysctl -w net.ipv4.ip_forward=1` 来设置内核网络层允许转发 IP 数据包。

* **sysfs**
  
* 它的做法也是通过文件 `/sys` 来完成用户态和内核的通信。和 procfs 不同的是，sysfs 是将一些原本在 procfs 中的，关于设备和驱动的部分，独立出来，以 “设备树” 的形式呈现给用户。sysfs 不仅可以从内核空间读取设备和驱动程序的信息，也可以对设备和驱动进行配置。
  
* **netlink**

  * netlink 是 Linux 用户态与内核态通信最常用的一种方式。Linux kernel 2.6.14 版本才开始支持。它本质上是一种 socket，常规 socket 使用的标准 API，在它身上同样适用。比如创建一个 netlink socket，可以调用如下的 socket 函数：

    ```
    #include <asm/types.h>
    #include <sys/socket.h>
    #include <linux/netlink.h>
    
    netlink_socket = socket(AF_NETLINK, socket_type, netlink_family);
    ```

  netlink 这种灵活的方式，使得它可以用于内核与多种用户进程之间的消息传递系统，比如路由子系统，防火墙（Netfilter），ipsec 安全策略等等。

* **事务特性**
  
  * 原子性
  * 一致性
  * 隔离性
  
  * 持久性
  
* **数据库drop，delete和truncate区别**
  
  * drop直接删掉表
  * delete删除表中数据，可以添加限定where
  * truncate一次性删除表中所有数据
  
* **线程中栈的分配**

  一般默认情况下，线程栈是在**进程的堆中分配栈空间，每个线程拥有独立的栈空间**，为了避免线程之间的栈空间踩踏，线程栈之间还会有以小块guardsize用来隔离保护各自的栈空间，一旦另一个线程踏入到这个隔离区，就会引发段错误。

* **为什么mysql用b+树不用b树**

  * **b+树只有叶节点存放数据，其余节点是用来存放索引的,这让b+树更适合存储外部数据**

  * **数据量大的索引，为了减少内存占用，索引存储在磁盘里，由于b+树不是叶节点部分不带数据，因此节点比较小，减少了IO次数**
  * **另外，由于b+树所有data都在叶节点，因此一般会有优化，所有叶子节点都用指针串起来，这样就可以遍历叶子节点获取全部数据，进行区间访问**

* **虚拟内存**

  * **基本思想**：每个程序有自己的地址空间，这个空间被分割成多个块，每一块称作一页或者**页面**。每一页有连续的地址范围。**这些页被映射到物理内存**，但不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。**当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令**

  * **读写操作中虚拟地址被送到内存管理单元（MMU），MMU把虚拟地址映射为物理内存地址**
  * **页表给出了虚拟地址和物理地址之间的映射关系**

  * **缺页中断**，操作系统找到一个**很少使用的页框并且把它的内容写入到磁盘，随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的命令**
  * **一个虚拟地址，后多少位是页面内的偏移量，而中间部分是页号数，这跟页表的大小有关**
  * **之后通过页号作为索引查找对应的物理内存的页框，将页框值左移后加上偏移量就是物理地址 p111有图示和详细说明**
  * 页表项内部是有**页框号**、**在不在位**、**保护位**、**修改位**、**访问位**、**禁止高速缓存位**。
  * 注意如果某个页面不在内存中，页表是不会保存**页面的磁盘地址的**

  * **加速分页过程·**
    
  * **TLB**,转换检测缓冲区，**又称快表**
    
  * **针对大内存的页表**

    * **多级页表**

      **比如32位的地址，前十位为PT1域，对应顶级页表，中间十位对应PT2域，对应二级页表，最后12位为偏移量**

  * **页面置换算法**

    * **最近未使用**

    * **先进先出**

    * **第二次机会**

    * **时钟页面置换算法**

    * **最近最少使用**

      **代价很高**

* **与分页有关工作**

  * 操作系统要做的分页相关工作：**进程创建时、进程执行时、缺页中断时、进程中止时**

  * **缺页中断处理** **p131**

* **倒排索引**

  搜索引擎中，每个文件对应一个文件ID，文件内容被表示为一系列关键词的集合，得到**正向索引**如下：

   “文档1”的ID > 单词1：出现次数，出现位置列表；单词2：出现次数，出现位置列表；…………。

  “文档2”的ID > 此文档出现的关键词列表。

  这样搜索关键字**需要搜索所有文档，太慢**，

  **倒排索引即将文件id对关键词的映射转换为关键词到文件id的映射**

  ​    “关键词1”：“文档1”的ID，“文档2”的ID，…………。

  ​    “关键词2”：带有此关键词的文档ID列表。

* **static在c和c++中**

  在c++中，不仅支持传统C语言中static的特性，如：全局静态函数，局部静态变量，静态函数等，还对static进行了扩展，支持**静态数据成员，静态函数成员，静态对象等**。

* **static**

  静态全局变量和静态函数的作用域都在**一个源文件内**，而全局变量和普通函数作用域可以在整个项目中。

  静态函数的作用域为当前的源文件，而局部函数的作用域为整个工程。但是静态函数会被一直放在一个一直使用的存储区，直到退出应用程序实列，**避免了调用函数时的压栈和出栈，速度快很多**。

  **静态成员函数本身只能访问静态成员，不能访问非静态成员**

* **extern c**

  extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。**加上extern "C"后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译**。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；**而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名**。

* **内存对齐**

  内存对齐，对齐规则是按照成员的声明顺序，依次安排内存，其**偏移量为成员大小的整数倍**，0看做任何成员的整数倍，**最后结构体的大小为最大成员的整数倍**。

  内存对齐原因：

  1. **访问未对齐的内存，处理器要访问两次（数据先读高位，再度地位），访问对齐的内存，处理器只要访问一次**，因为处理器**不能从任意位置读取数据**，如果没有对齐可能就要都两次才读完。
  2.  使用内存对齐的原因还有**平台的原因**：不是所有的硬件平台都能访问特定的地址上的任意数据，某些平台只能访问特定的地址上的获取数据，否则会抛出异常。

* **半连接完成队列**

  说的其实是unp中的**未完成连接队列**，与listen的**backlog**相关，

  内核为任何一个给定的监听套接字维护两个队列：**未完成连接队列**，**已完成连接队列**。

* **tcp如何保证可靠传输**
  * 应用程序被分割为tcp认为最适合发送的数据块
  * 对每一个数据块进行**编号**，接收方对数据包进行排序。
  * **检验和**，**检验数据在传输过程中发生的变化**。
  * **流量控制**，防止超过缓冲区大小导致包丢失
  * **拥塞控制**

* **拥塞控制**

  拥塞窗口设为**cwnd**，

  * **慢启动**

    cwnd初始设为一个MSS的**较小值**，**每次确认都会增加一个MSS**。因此是**指数增长的**。

  * **拥塞避免**

    进入拥塞避免状态，cwnd的值是**上次遇到拥塞时的一半**。在这个阶段是每次收到一个确认就见cwnd增加MSS/cwnd个字节。因此是**线性增长的**。

    **出现超时cwnd设为1个mss，继续慢启动**

* **线程通信**

* **锁**

  [锁](https://www.cnblogs.com/jyroy/p/11365935.html)

* **get和post区别**

  * 报文方面：

    报文格式不同，即请求报文的第一行开头是GET还是POST的区别。

    另外参数，get方法的**参数放在url里面**，post方法的参数放在**body里面**。

  * **安全方面**

    post相对于get较为安全，因为数据在地址栏是不可见的。

    **从传输的角度讲，都是不安全的，http在网络上都是明文传输的，只要在网络上捉包就能完整地获取报文**

  * **get的长度限制**

    **http协议并没有body和url的长度限制**，这种限制大多是**浏览器或者服务器的原因**。

  * 其他http请求方法：

    | HEAD    | 与 GET 相同，但只返回 HTTP 报头，不返回文档主体。 |
    | ------- | ------------------------------------------------- |
    | PUT     | 上传指定的 URI 表示。                             |
    | DELETE  | 删除指定资源。                                    |
    | OPTIONS | 返回服务器支持的 HTTP 方法。                      |
    | CONNECT | 把请求连接转换到透明的 TCP/IP 通道。              |

* **事务隔离等级**

  [事务隔离等级](https://baijiahao.baidu.com/s?id=1611918898724887602&wfr=spider&for=pc)

* **HTTPS连接过程**

  * **客户端发起HTTPS请求**

  * 服务器有一套数字证书，这个证书其实是一对公钥和私钥**

  * 传送证书，即**传送公钥，其中包含了证书的颁发机构和过期时间**

  * **客户端解析证书**

    **如果证书没有问题，就生成一个随机值，然后用证书对该随机值进行加密。**

  * **传送加密信息**

  * **服务器解密**

    **通过解出来的随机值作为私钥，将内容通过该值进行对称加密**，**即讲信息和私钥通过某种方法混合在一起**

  * **传输加密后的信息**

  * **客户端解密信息**

* **LINUX启动过程**

  * **加载bios**

    bios中包含了**CPU的相关信息、设备启动顺序信息、内存信息、时钟信息、PNP特性等等**。

  * **读取MBR**

    **磁盘上第0磁道的第一个扇区称为MBR，即主引导记录，大小为512字节**。

    **里面放置了预启动信息、分区表信息**

    *系统找到BIOS所指定的硬盘的MBR后，就会将其复制到0×7c00地址所在的物理内存中。其实被复制到物理内存的内容就是Boot Loader，而具体到你的电脑，那就是lilo或者grub了。*

  * **Boot Loader**

    **Boot Loader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核做好一切准备。**

    **Grub就是常见的boot loader**

  * **加载内核**

    根据grub设定的内核映像所在路径，**系统读取内存映像，并进行解压缩操作**。此时，屏幕一般会输出“Uncompressing Linux”的提示。**当解压缩内核完成后，屏幕输出“OK, booting the kernel”**。
    系统将解压后的内核放置在内存之中，**并调用start_kernel()函数来启动一系列的初始化函数并初始化各种设备，完成Linux核心环境的建立**。至此，Linux内核已经建立起来了，基于Linux的程序应该可以正常运行了。

  * **用户层init依据inittab文件来设定运行等级**

    内核被加载后，第一个运行的程序便是/sbin/init，该文件会读取/etc/inittab文件，并依据此文件来进行初始化工作。
    **其实/etc/inittab文件最主要的作用就是设定Linux的运行等级**

  * **init进程执行rc.sysinit**

    在设定了运行等级后，Linux系统执行的第一个用户层文件就是/etc/rc.d/rc.sysinit脚本程序，它做的工作非常多，包括设定PATH、设定网络配置（/etc/sysconfig/network）、启动swap分区、设定/proc等等。

  * 启动内核模块
  * 执行不同运行级别的脚本程序
  * 执行/etc/rc.d/rc.local
  * 执行/bin/login程序，进入登录状态

* **https状态码**

  | 状态码 | 意义                                           |
  | ------ | ---------------------------------------------- |
  | 200    | 请求成功                                       |
  | 400    | 参数错误                                       |
  | 403    | 拒绝或者禁止访问（无权限访问）                 |
  | 404    | 地址不存在                                     |
  | 405    | 客户端请求中的方法被禁止（一般是请求方式错误） |
  | 500    | 服务器报错                                     |
  | 502    | 请求超时，无效网关                             |
  | 503    | 服务器超载或者维护，无法响应                   |

* **timewait**
  * 可靠的实现TCP全双工连接的终止。
  * 允许老的重复分节在网络中消逝

* **malloc的底层实现**

  [他人博客](https://blog.csdn.net/z_ryan/article/details/79950737)

  [自己github总结](https://github.com/whukxggx/note/blob/master/malloc.md)

* **mmap**

  UNIX网络编程第二卷进程间通信对mmap函数进行了说明。该函数主要用途有三个：
  1、将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I/O读写，以获得较高的性能；
  2、将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间；
  3、为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。

* **weak_ptr解决循环引用问题**

  如果有一个类A和类B，其数据成员是一个shared_ptr指向彼此。那么此时类A和类B的引用计数ref为1。如果此时又有两个智能指针分别指向A和B，那么此时类A和类B的引用计数为2，当这两个智能指针离开其作用域的时候ref减为1，但并不会释放智能指针所指向的对象。会造成内存泄漏。

* **仿函数**

  **仿函数的主要功能是为了搭配STL算法使用，单独使用仿函数的情况比较少。**
  仿函数（functors）在C++标准中采用的名称是函数对象（function objects）。仿函数主要用于STL中的算法中，**虽然函数指针虽然也可以作为算法的参数，但是函数指针不能满足STL对抽象性的要求，也不能满足软件积木的要求–函数指针无法和STL其他组件搭配，产生更灵活变化。**仿函数本质就是类重载了一个operator()，创建一个行为类似函数的对象。

* **epoll**

  [epoll原理](https://blog.csdn.net/daaikuaichuan/article/details/83862311)

* **mysql索引**

  [介绍](https://blog.csdn.net/liuchangjie0112/article/details/90606916)

  * 索引类型

    **最左前缀**

  * 何时建立索引

  * 索引不足

  * 注意事项

* **rpc**

  [rpc基本概念](https://www.cnblogs.com/haimishasha/p/11573512.html)

* **shared_ptr注意事项**

  **shared_ptr多次引用同一数据，会导致两次释放同一内存。**

  **shared_ptr循环引用导致内存泄露**

* **DDoS**

  **全称Distributed Denial of Service，中文意思为“分布式拒绝服务”**

  **就是利用大量合法的分布式服务器对目标发送请求，从而导致正常合法用户无法获得服务。**

  [介绍](https://www.jianshu.com/p/e7a5fdc67b8f)

* **饥饿**

   **如果一个线程因为处理器时间全部被其他线程抢走而得不到处理器运行时间，这种状态被称之为`饥饿`，一般是由高优先级线程吞噬所有的低优先级线程的处理器时间引起的。**

   * **解决：**

     **多级反馈队列调度算法**

     **1、**进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。

     **2、**首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：Q1,Q2,Q3三个队列，当且仅当在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。

     **3、**对于同一个队列中的各个进程，按照FCFS分配时间片调度。比如Q1队列的(时间片/6525414)为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。

     **4、**在最后一个队列QN中的各个进程，按照时间片轮转分配时间片调度。

     **5、**在低优先级的队列中的进程在运行时，又有新到达的作业，此时须立即把正在运行的进程放回当前队列的队尾，然后把处理机分给高优先级进程。换而言之，任何时刻，只有当第1~i-1队列全部为空时，才会去执行第i队列的进程（抢占式）。特别说明，当再度运行到当前队列的该进程时，仅分配上次还未完成的时间片，不再分配该队列对应的完整时间片。

* **malloc和mmap的区别，映射区是什么**

   mmap - 创建内存映射区

   - 作用：将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件

* **一条MySQL语句执行过程**

   1. **连接数据库**

      1. 客户端发起一条Query请求，服务器端的‘连接管理模块’接收请求。
      2. 将请求转发到‘连接进/线程模块’。
      3. 调用‘用户模块’来进行授权检查。
      4. 通过检查后，‘连接进/线程模块’从‘线程连接池’中取出空闲的被缓存的连接线程和客户端请求对接，如果失败则创建一个新的连接请求。

   2. **处理请求**

      1. **查询缓存** 通过一个大小写敏感的哈希查找判断查询是否命中查询缓存的数据。
1. 命中查询缓存，用户权限没有问题，MySQL直接从缓存中拿结果返回给客户端。
   
2. **查询优化处理**（**解析SQL、预处理、优化SQL的执行计划**），**将SQL转化成一个执行计划】**
   
3. 1. **解析和预处理：**生成一棵解析树（《编译原理》的知识），MySQL按照其语法对解析树进行验证和解析查询。判断语法是否合法。这里可以对比一下存储过程和 PHP 或者 Java 的预处理过程，它们就是因为存储了预处理过程的结果，所以可以达到 SQL 的拼接和提高一些效率。
         2. **优化器和执行计划：**将语法树转化为执行计划（子任务），并选择成本尽量小的执行计划。
   
4. 1. 1. 优化过程书上介绍了很多情况，请参考书籍6.43章
            2. 执行计划 MySQL会生成一个指令树，然后通过存储引擎完成这棵树并返回结果 如图2
   
5. **查询执行引擎** 查询执行引擎则根据执行计划来完成整个查询。在执行计划时，存储引擎通过调用实现的接口来完成。
   
3. **返回结果**
   

[另一个版本执行过程](https://www.jianshu.com/p/338092a0a8c6)

* **vector在栈还是堆上**

  vector map ....都是通过stl的allocator进行内存分配的，如果你有注意过模板的话他们都会提供一个默认的allocator。
  所以你用不同的创建方式创建出来的容器对象可以在栈或者堆上，而**内容数据永远都是在堆上的**。
  还有，**栈是没法做到动态管理的**。

* **tcp滑动窗口**

   

* **map迭代器**

  **map拥有和list相同的某些性质：当客户端对它进行元素新增操作时或删除操作时，操作之前的所有迭代器依然有效，当然，被删除的那个迭代器是个例外**

* **c中的全局变量链接时候重定义问题**

  在头文件中用 extern int my_global;//声明的作用

  在用到的c文件中用int my_global；

* **extern**

  可置于变量或者函数前，以表示变量或者函数的定义在别的文件中。提示编译器遇到此变量或者函数时，在其它模块中寻找其定义。

* **tcp优雅关闭**

  优雅关闭是指，**如果发送缓存中还有数据未发出则其发出去，并且收到所有数据的ACK之后，发送FIN包，开始关闭过程。**而强制关闭是指如果缓存中还有数据，则这些数据都将被丢弃，然后发送RST包，直接重置TCP连接。

  [详解优雅和非优雅](https://www.cnblogs.com/wangjiyuan/p/tcpclose.html)

* **时间轮**

  **调度模型，时间轮是为了解决高效调度任务而产生的调度模型**

  数据结构，通常为**哈希表和链表**实现。

  **优势**：

  **相比传统的队列形式的调度器来说，时间轮能够批量高效的管理各种延时任务、周期任务、通知任务等等。**

  **时间轮的原理和手表的指针计时类似，将任务结束的时间加入对应最高阶的时间轮转盘中。例如任务结束时间为4：30：20，时间轮盘有三个，分别对应，小时，分钟和秒。开始时将任务加入4小时所在的时间轮中。四小时过去后，任务的剩余时间时间为0：30：20就将任务加入30分所在的时间轮中。30分钟过去后，将任务降入存入20秒对应的轮盘中，直到到达第一个轮盘中到时删除任务。**

* **c++11新特性**

  [常用总结](https://www.cnblogs.com/chengjundu/p/10893702.html)

* **shared_ptr**

  shared_ptr肯定是线程安全的，但是

  ```text
  *shared_ptr.get()
  ```

  就不一定。这是初学者容易弄混的地方。指针的内容并不归指针管。

* **cap**

  CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。

* **mysql索引优点**
  
  * **快速定位到表的指定位置**
  * **索引大大减少了服务器需要扫描的数据量**
  * **所以可以帮助服务器避免排序和临时表**
  * **索引可以将随机I/O变为顺序I/O**

* **sql存储过程详解**

* **define和const**

  **Const在堆栈分配了空间，而#define只是把具体数值 直接传递到目标变量罢了。**或者说，const的常量是一个Run-Time的概念，他在程 序中确确实实的存在可以被调用、传递。而#define常量则是一个Compile-Time概 念，它的生命周期止于编译期：在实际程序中他只是一个常数、一个命令中的参 数，没有实际的存在。 const常量存在于程序的数据段。 #define常量存在于程序的代码段。

* **解释DNS域名解析的过程：**

  网络客户端就是我们平常使用的电脑，打开浏览器，输入一个域名。比如输入`www.baidu.com`，这时，你使用的电脑会发出一个DNS请求到本地DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。
  查询`www.baidu.com`的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果。如果没有，本地DNS服务器还要向DNS根服务器进行查询。
  根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。
  本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。
  最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。

* **阻止拷贝和赋值**

  ```c++
  struct NoCopy{
      NoCopy()=default;
      NoCopy(const NoCopy&)=delete;
      NoCopy &operator=(const NoCopy&) = delete;    
      ~NoCopy()=default;
  }
  ```


* **netstat**

  netstat命令的功能是百显示网络连接、路由表和网络接口信息，可以让用户得知有哪些网络连接正在运作。使用时如果不带参度数，netstat显示活动的 TCP 连接。

* **共享内存**
  进程间通信使用的数据结构:管道、socket、共享内存、消息队列、信号量等，是属于内核级的，一旦创建后就由内核管理，若进程不对其主动释放，那么这些变量会一直存在，除非重启系统。

* **udp报文段结构**

  **源端口号，目的端口号，长度，检验和，应用数据**

* **tcp报文段结构**

  **源端口号，目的端口号，序号，确认号，检验和，接受窗口字段，首部长度，6比特的标志字段，**

* **POD类型**

  POD，是Plain Old Data的缩写，普通旧数据类型，是C++中的一种数据类型概念*

  POD类型与C编程语言中使用的类型兼容，**POD数据类型可以使用C库函数进行操作，也可以使用std::malloc创建，可以使用std::memmove等进行复制，并且可以使用C语言库直接进行二进制形式的数据交换**

* **系统调用消耗更多时间**

  *用户进程位于用户空间，内核进程位于系统空间，磁盘只能被内核直接访问*

  在运行内核代码时，CPU工作在管理员模式，**这对应于一些特殊的堆栈和内存环境，必须在系统调用时切换到这个环境中。系统调用结束后，CPU要切换到用户模式，又要将堆栈和内存环境恢复到用户模式的状态，这种内存环境的切换要耗费很多时间。**

  因此，**系统调用所耗费的时间主要在两次环境切换上*8，如果用户程序中普通代码和系统调用交替出现，那么将产生很大的环境切换的开销。

* **聚集索引**

  * **聚集的数据的优点**：
    * **可以把相关数据保存在一起。** 例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有聚簇索引，**则每封邮件都可能导致一次磁盘IO。**
    * **数据访问更快**，聚簇索引将**索引和数据保存在一个B-tree里面**，因此从聚簇索引中获取数据通常比在非聚簇索引更快
    * **使用聚簇索引扫描的查询可以直接使用页节点中的主键值**

  * **缺点**
    * 聚簇索引最大限度的提高了I/O密集型应用的性能，但是如果数据全部存放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。
    * **插入速度严重依赖于插入顺序**。**按照主键顺序插入是加载数据到innodb表中速度最快的方式。
    * **更新代价很高**，**因为会强制Innodb将每个被更新的行移动到新的位置**
    * **基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂问题**。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行。**页分裂导致表占据更多的存储空间**
    * **聚簇索引导致全表扫面变慢**。
    * **二级索引(非聚簇索引)可能比想象中的要更大，因为在二级索引的叶子节点包含了引用行的主键列**
    * **二级索引需要两次索引查找，而不是一次**。*二级索保存的不是指向行的物理位置的指针，而是行的主键值*。

* **多态**

  * **静态多态**

    静态多态：也称为编译期间的多态，编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。

  * **动态多态**

    动态多态（动态绑定）：即运行时的多态，在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法。

  * **多态好处**

    提高了代码的维护性（继承保证）；提高了代码的**扩展性**。

    把不同的子类对象都当作父类来看,可以屏蔽不同子类对象之间的差异,写出通用的代码,做出通用的编程,以适应需求的不断变化。 赋值之后,父类型的引用就可以根据当前赋值给它的子对象的特性以不同的方式运作。

* **构造函数抛出异常**

  1. 构造函数中抛出异常，会导致析构函数不能被调用，但对象本身已申请到的内存资源会被系统释放（已申请到资源的内部成员变量会被系统依次逆序调用其析构函数）。

  2. 因为析构函数不能被调用，所以可能会造成内存泄露或系统资源未被释放。

  3. 构造函数中可以抛出异常，但必须保证在构造函数抛出异常之前，把系统资源释放掉，防止内存泄露。

* **qq udp**

  首先,QQ并不是完全基于UDP实现。
  比如在使用**QQ进行文件传输等活动的时候，就会使用TCP作为可靠传输的保证**。

  使用UDP进行交互通信的好处在于，**延迟较短，对数据丢失的处理比较简单**。
  同时，TCP是一个全双工协议，需要建立连接，所以网络开销也会相对大。如果使用QQ语音和QQ视频的话，UDP的优势就更为突出了，首先延迟较小。最重要的一点是**不可靠传输，这意味着如果数据丢失的话，不会有重传**。因为用户一般来说可以接受图像稍微模糊一点，声音稍微不清晰一点，但是如果在几秒钟以后再出现之前丢失的画面和声音，这恐怕是很难接受的。

  UDP协议是无连接方式的协议，它的效率高，速度快，占资源少，但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。QQ采用的通信协议以UDP为主，辅以TCP协议。

  **由于QQ的服务器设计容量是海量级的应用，一台服务器要同时容纳十几万的并发连接，因此服务器端只有采用UDP协议与客户端进行通讯才能保证这种超大规模的服务。**

* **CA证书**
  * 客户端访问服务器（比如：https://www.12306.cn）,发送ssl版本、客户端支持的加密算法、随机数等消息。
  * **服务器向客户端发送ssl版本、随机数、加密算法、证书（证书出现了）等消息。**
  * 客户端收到消息后，判断证书是否可信，若可信，则继续通信，发送消息包括：向服务器发送一个随机数，从证书中获取服务器端的公钥，对随机数加密；编码改变通知，表示随后信息都将使用双方协定的加密方法和密钥发送；客户端握手结束通知。
  * 服务器端对数据解密得到随机数，发送消息：编码改变通知，表示随后信息都将使用双方协定的加密方法和密钥发送。

* **内存泄漏检测**

  **valgrind是一个检测内存泄露的工具。**

* **sql注入**

  SQL注入（SQLi）是一种注入攻击，，可以执行恶意SQL语句。它通过将任意SQL代码插入数据库查询

  [例子](https://www.cnblogs.com/liuzeyu12a/p/10046228.html)

* 假设一个磁盘中断发生时，用户进程3正在运行，则**中断硬件将程序计数器，程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址，这是硬件所完成的工作，然后软件接管**

* sql查询慢的优化：
  * 不要在字段前面进行加减运算
  * 字符串较长的可以考虑索引一部分减少索引文件大小
  * like %在前面用不到索引
  * 根据联合索引的第二个及以后的字段单独查询用不到索引
  * 不要使用select *，因为它会进行全表扫描，不能有效利用索引，增大了数据库服务器的负担，以及它与应用程序客户端之间的网络IO开销

* 非对称加密加密解密**算法效率较低**，不适合客户端和服务器端这样高频率的通信过程，在某些极端情况下，甚至能比非对称加密慢上1000倍。