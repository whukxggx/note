### 虚函数
1. 在c++中，当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定。
2. 基类通常都应该定义一个虚析构函数，即使该函数不执行任何操作。
3. 任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。
4. 如果基类把一个函数声明为虚函数，那它在派生类中隐式的也是虚函数。
5. 派生类经常但不总是覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会
直接继承它在基类中的版本。
6. 每个类控制它自己的成员初始化过程。每个类负责定义各自的接口。想要与类的对象交互必须适用该类的接口，即使这个对象是派生类的基类
也是这样。因此，派生类不能直接初始化基类的成员，尽管从语法上来说我们可以在派生类构造函数体内对它的公有或受保护的基类成员赋值，但是最好不这么做。
7. 必须为每一个虚函数提供定义，不管它是否被用到，因为连编译器也不知道哪个被用到，直到运行时才知道调用了哪个版本的虚函数。
8. 引用或指针的静态类型与动态类型不同这一事实正是c++语言支持多态性的根本所在。
9. 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。
10. 当我们使用基类的引用或者指针调用基类中定义的一个函数的时候，如果该函数是虚函数，直到运行时才会决定到底执行哪个版本，判断的依据是引用或指针所绑定的对象的真实类型。对非虚函数的绑定则是在编译时就确定的。对通过对象进行的函数（无论是虚函数还是非虚函数）都是在编译时绑定的。
11. 一旦某个函数被声明为虚函数，则在每个派生类中它都是虚函数。
12. 一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被他覆盖的虚函数完全一致。
13. 派生类中虚函数的返回类型也必须与基类函数匹配。一个例外是当类的虚函数返回的是类本身的指针或引用时无效。
#### final和override

14. 如果我们使用override标记了某个函数，而这个函数并没有覆盖已存在的虚函数，此时编译器将报错。
15. 只有虚函数才能被覆盖。
16. 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。
17. 回避虚函数的机制：使用作用域运算符。
```
//强调调用基类定义中的函数版本而不管baseP的动态类型到底是什么。
double undiscounted = basep->Quote::net_price(42);
```
通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制。
18. 如果一个派生类虚函数需要调用它的基类版本，但是并没有用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。
### 静态成员
1. 通过在成员的声明面前加上关键字static使其与类关联在一起。静态成员对象是被所有类的实例化对象所共享的。
2. 类似的，静态成员函数也不与任何对象绑在一起，他们不包含this指针，函数也不能声明为const的，也不能在static函数内使用this指针。
3. 当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句。
### 继承
1. 如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。（一层隐含的意思，一个类不能派生它本身)。
2. 类名后面跟一个关键字final可以防止被其他类继承。
### 类型转换
1. 如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。
2. 不存在从基类向派生类的隐式类型转换。（原因很简单，基类不包括派生类自身的成员，派生类包含一个基类部分）。
3. 如果在基类中含有一个或多个虚函数，我们可以使用dynamic_cast请求一个类型转换，该转换的安全检查将在运行时执行。同样，
如果我们知道某个基类向派生类的转换是安全的，则我们可以使用static_cast来强制覆盖掉编译器的检查工作。
4. 派生类向基类的自动类型转换只对指针或引用有效。
5. 

### 抽象基类





#### 左右值

当一个对象被用作右值的的时候，用的是对象的值(内容)；当对象被用作左值的时候，用的是对象的身份(在内存中的位置);

调用move就意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它。即我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。

#### 引用折叠和右值引用参数

两个例外规则：

* 第一个例外规则影响右值引用参数的推断如何进行。当我们将一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数时(如T &&)时，编译器推断模板类型参数为实参的左值引用类型。
* 第二个例外绑定规则：如果我们间接创建一个引用的引用，则这些引用形成了“折叠”。在所有情况下，引用会折叠成一个普通的左值引用类型。在新标准中，折叠规则扩展到右值引用。只在一种特殊情况下引用会折叠成右值引用：右值引用的右值引用。即,对于一个给定类型X：
  * X& &,X& &&和X && &都折叠成类型X&
  * 类型X && &&折叠成X &&

以上两个规则导致了两个重要结果：

* 如果一个函数参数是一个指向模板类型参数的右值引用（如，T&&),则它可以被绑定到一个左值；且
* 如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个左值引用参数。

__type_traits